%{
#include "tree.h"
#include<stdio.h>
#include<iostream>
#include<map>
#include<vector>
std::map<std::string,double> varTable;
std::map<std::string,std::string> typeTab;
std::map<std::string,std::string> varStringTbl;
std::vector<VarInitExprAST*> args;
std::vector<ExprAST*> lines;
extern int yylex(void);
extern void storeVar(char*,double);
extern void storeStringVar(char*,char*);
extern int lineNum;
extern map<std::string, llvm::AllocaInst*> NamedValues;
using namespace std;
void yyerror(char const *s) 
{ 
  cerr << "\033[31m ERROR: \033[37m" << s << " in line: " << lineNum << endl;
}
%}

%code requires
{
#include "tree.h"
}

%require "3.0"
%error-verbose

%union
{
  int intVal;
  char charVal;
  double doubleVal;
  const char* strVal;
  VarInitExprAST* varInit;
  FunctionAST* fdef;
  PrototypeAST* proto;
  CallExprAST* funcCall;
  IfExprAST* _if;
  BinaryExprAST* bo;
  DoubleExprAST* dval;
  IntExprAST* ival;
  ExprAST* expr;
  stringExprAST* strAST;
  CharExprAST* charAST;
  UnaryExprAST* uo;
};

%token NUMBER FLOAT
%token STRING ID END CHARACTER
%token FUNC KERNEL EXTERN FOR IF ELSE ELIF MODULE RETURN
%token INT DOUBLE CHAR STR
%token RARROW LARROW CAROT
%token EQUAL GT LT GTE LTE NEQUAL PLUS MINUS MUL DIV MOD EMARK QMARK AND OR LSBRACE RSBRACE LPAREN RPAREN LBRACE RBRACE AT DOT COMMA COLON SEMICOLON

%left EQUAL;
%left LT GT LTE GTE;
%left PLUS MINUS;
%left MUL DIV;
%nonassoc LPAREN

%type <intVal> NUMBER
%type <doubleVal> FLOAT
%type <strVal> INT
%type <strVal> DOUBLE
%type <strVal> CAROT
%type <strVal> AT
%type <strVal> CHAR
%type <strVal> STR 
%type <strVal> STRING
%type <strVal> SEMICOLON
%type <strVal> PLUS
%type <strVal> MINUS
%type <strVal> DIV
%type <strVal> MUL
%type <strVal> DOT
%type <strVal> EQUAL
%type <strVal> FUNC
%type <strVal> MODULE
%type <strVal> EXTERN
%type <strVal> KERNEL
%type <strVal> RARROW
%type <strVal> LARROW
%type <strVal> LBRACE
%type <strVal> LPAREN
%type <strVal> RPAREN
%type <strVal> RBRACE
%type <strVal> ID
%type <charVal> CHARACTER

%type <strVal> dataType 
%type <varInit> varDef
%type <proto> funcDef
%type <proto> funcProto
%type <funcCall> funcCall
%type <_if> ifBranch
%type <bo> binOp
%type <expr> numVal
%type <charAST> chara
%type <uo> unaryOp
%type <strVal> pointerType

%start program

%%
program: expressions

expressions: expressions expression
           | expression

expression: varDef  { lines.push_back($1); }
          | funcDef  { createfuncDef(new FunctionAST($1,lines)); lines.clear(); NamedValues.clear(); }
          | kernelDef 
          | modImport 
          | extern 
          | funcCall  { lines.push_back($1); }
          | ifBranch  { lines.push_back($1); }
          | binOp  { lines.push_back($1); }
          | chara { lines.push_back($1); }
          | unaryOp {lines.push_back($1); }
          | ID  { lines.push_back(new VariableExprAST($1,typeTab[$1])); }

modImport: MODULE ID SEMICOLON { cout << "Module loaded: " << $2 << endl; }

funcParams: ID
          | numVal
          | chara
          | binOp

chara: CHARACTER { $$ = new CharExprAST($1); }

funcCall: ID LPAREN funcParams RPAREN { cout << "Calling func " << $1 << endl; }
        | ID LPAREN RPAREN { cout << "Calling func " << $1 << endl; }

extern: EXTERN funcProto SEMICOLON
      | EXTERN kernelProto SEMICOLON

dataType: INT { $$ = "int"; }
        | DOUBLE { $$ = "double"; }
        | CHAR { $$ = "char"; }
        | STR { $$ = "string"; }
        | pointerType  { $$ = $1; }

pointerType: INT CAROT { $$ = "ints"; }
           | DOUBLE CAROT { $$ = "doubles"; }
           | CHAR CAROT { $$ = "chars"; }

varDef: dataType ID { $$ = new VarInitExprAST($2,$1,NULL); typeTab[$2] = $1; }
      | dataType ID EQUAL binOp { $$ = new VarInitExprAST($2,$1,$4); typeTab[$2] = $1; }
      | dataType ID EQUAL unaryOp { $$ = new VarInitExprAST($2,$1,$4); typeTab[$2] = $1; }

paramDefs: paramDefs COMMA paramDef
         | paramDef 

paramDef: dataType ID { VarInitExprAST* temp = new VarInitExprAST($2,$1,NULL); args.push_back(temp); createVarDef(temp); cout << "Parameter defined!\n"; }

block: LBRACE expressions RBRACE
     | LBRACE RBRACE

/*forLoop: FOR ID EQUAL expression COMMA expression block
       | FOR ID EQUAL expression COMMA expression COMMA expression block 
*/
elseBranch: ELSE block
          | ELIF block elseBranch

ifBranch: IF expression block 
        | IF expression block elseBranch

funcDef: funcProto block { $$ = $1; }

kernelDef: kernelProto block { cout << "Kernel defined!\n"; }

kernelProto: KERNEL ID LPAREN paramDefs RPAREN LARROW NUMBER 
           | KERNEL ID LPAREN           RPAREN LARROW NUMBER

funcProto: FUNC ID LPAREN paramDefs RPAREN RARROW dataType { $$ = new PrototypeAST($2,args,$7); args.clear(); }
         | FUNC ID LPAREN           RPAREN RARROW dataType { $$ = new PrototypeAST($2,args,$6); args.clear(); }

unaryOp: ID CAROT { $$ = new UnaryExprAST('^',new VariableExprAST($1,typeTab[$1])); }

numVal: NUMBER { $$ = new IntExprAST($1); }
      | FLOAT { $$ = new DoubleExprAST($1); }
      | chara

binOp: numVal
     | LPAREN binOp RPAREN { $$ = $2; }
     | ID PLUS ID { $$ = new BinaryExprAST('+', new VariableExprAST($1,typeTab[$1]), new VariableExprAST($3,typeTab[$3])); }
     | ID MINUS ID { $$ = new BinaryExprAST('-', new VariableExprAST($1,typeTab[$1]), new VariableExprAST($3,typeTab[$3])); }
     | ID DIV ID { $$ = new BinaryExprAST('/', new VariableExprAST($1,typeTab[$1]), new VariableExprAST($3,typeTab[$3])); }
     | ID MUL ID { $$ = new BinaryExprAST('*', new VariableExprAST($1,typeTab[$1]), new VariableExprAST($3,typeTab[$3])); }
     | ID EQUAL binOp { $$ = new BinaryExprAST('=', new VariableExprAST($1,typeTab[$1]),$3); }
     | ID EQUAL unaryOp { $$ = new BinaryExprAST('=', new VariableExprAST($1,typeTab[$1]), $3); }
     | binOp PLUS binOp { $$ = new BinaryExprAST('+',$1,$3); }
     | binOp MINUS binOp { $$ = new BinaryExprAST('-',$1,$3); }
     | binOp DIV binOp { $$ = new BinaryExprAST('/',$1,$3); }
     | binOp MUL binOp { $$ = new BinaryExprAST('*',$1,$3); }
